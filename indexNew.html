<!DOCTYPE html>
<html lang="en">

<head>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js"
        crossorigin="anonymous"></script>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Toma-ru</title>
</head>

<body>
    <section id="control-buttons">
        <button id="enable-sensors-button">Enable Sensors</button>
    </section>
    <section id="sensor-stats-container">
        <h3>GPS: <span id="gps-stat">disabled</span></h3>
        <h3>Cam: <span id="camera-stat">disabled</span></h3>
    </section>
    <section id="socket-stats">
        <h3>wss: <span id="websocket-stat">disconnected</span></h3>
        <section id="socket-logs">
            <div class="log">
                <h4>10:20:30</h4>
                <p>content</p>
            </div>
        </section>
    </section>
    <section id="object-detection">
        <h1 id="detections-text">
            car: 80%
        </h1>
    </section>
</body>
<script>
    function formatTimeHourMinuteSecond(dateObject){
        return `${dateObject.getHours()}:${dateObject.getMinutes()}:${dateObject.getSeconds()}`;
    }
</script>
<script>
    const ws = new WebSocket(`wss://${currentHtmlUrl}`);
    ws.addEventListener("open", (event) => {
        document.querySelector("#websocket-stat").innerHTML = "connected";
    });
    ws.addEventListener("message", (event) => {
        if (event.data instanceof Blob) {
            const reader = new FileReader();

            reader.onload = function () {
                console.log("from server:", reader.result);
                document.querySelector("#socket-logs").innerHTML += buildLogElement(formatTimeHourMinuteSecond(), reader.result);
                if (reader.result == "startcam") {
                    window.sessionStorage.cameraStarted = true;
                    ws.send("camera started");
                }
            };
            reader.onerror = function () {
                console.error("FileReader error:", reader.error);
            };
            reader.readAsText(event.data);
        } else {
            console.log(`from server: ${event.data}`);
            document.querySelector("#socket-traffic").innerHTML += buildLogElement(formatTimeHourMinuteSecond(), reader.result);
        }
        //handleLineLimit();
    });
</script>
<script>
    window.sessionStorage.cameraStarted = false;

    import { ObjectDetector, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.2";
    const vision = await FilesetResolver.forVisionTasks(
        // path/to/wasm/root
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm"
    );
    const objectDetector = await ObjectDetector.createFromOptions(vision, {
        baseOptions: {
            //modelAssetPath: `https://storage.googleapis.com/mediapipe-tasks/object_detector/efficientdet_lite0_uint8.tflite`,
            modelAssetPath: `/model` //custom model
        },
        scoreThreshold: 0.45,
        runningMode: "VIDEO",
    });

    const enableWebcamButton = document.getElementById("webcamButton");
    enableWebcamButton.addEventListener("click", enableCam);

    let video = document.getElementById("webcam");
    function enableCam(e) {
        if (!objectDetector) {
            alert("Wait! objectDetector not loaded yet.");
            return;
        }

        // getUsermedia parameters
        const constraints = {
            video: {
                facingMode: "environment",
            },
        };

        // Activate the webcam stream.
        navigator.mediaDevices
            .getUserMedia(constraints)
            .then(function (stream) {
                video.srcObject = stream;
                video.addEventListener("loadeddata", predictWebcam);
            })
            .catch((err) => {
                console.error(err);
                /* handle the error */
            });
    }

    let lastVideoTime = -1;
    let previousFrameContainedCars = false;
    function predictWebcam() {
        // if image mode is initialized, create a new classifier with video runningMode.
        let startTimeMs = performance.now();

        // Detect objects using detectForVideo.
        if (video.currentTime !== lastVideoTime) {
            lastVideoTime = video.currentTime;
            const detections = objectDetector.detectForVideo(video, startTimeMs);

            displayDetections(detections);

            const distanceToCars = calculateDistanceFromDetections(detections);
            const containsConditionMatchingCars = containsDangerouslyCloseCars(distanceToCars, currentSpeed);
            if (containsConditionMatchingCars) {
                sendBrake();
            }
        }
        // Call this function again to keep predicting when the browser is ready.
        window.requestAnimationFrame(predictWebcam);
    }

    function calculateDistanceFromDetections(detections) {
        const result = [];
        for (let detection of detections) {
            let category = detection.categories[0].categoryName;
            if (category != "car") {
                continue;
            }
            //contains car
            let distanceToCar = calculateDistanceFromPixelHeight(detection.boundingBox.height);
            result.push(distanceToCar);
        }
        return result;
    }

    function containsDangerouslyCloseCars(distances, speed) {
        const currentBrakeDistance = calculateBrakingDistanceFromSpeed(speed);
        const distanceToSpare = 5 //change accordingly
        const filtered = distances.filter(distance => distance < currentBrakeDistance + distanceToSpare);
        return filtered.length;
    }

    function calculateBrakingDistanceFromSpeed(speed) {
        return 0.275 * speed + 0.008 * Math.pow(speed, 2)
    }

    function calculateDistanceFromPixelHeight(pixelHeight) {
        return 918 / pixelHeight - 0.23;
    }


    function displayDetections(detections) {
        let resultText = "";
        for (let detection of detections) {
            let category = detection.categories[0].categoryName;
            if (category != "car") {
                continue;
            }
            resultText += `car: ${Math.round(parseFloat(detection.categories[0].score) * 100)}<br>`;
        }
        document.querySelector("#detections-text").innerHTML = resultText;
    }

    function buildLogElement(formattedTimeString, content){
        return `
        <div class="log">
            <h4>${formattedTimeString}</h4>
            <p>${content}</p>
        </div>
        `;
    }

    async function sendBrake(distance, speed, brakeDistance) {
        const formattedDateString = await getCurrentTimeInString();
        //writeToPort("on");
        ws.send("brake");
        console.log(`brake sent at: ${formattedDateString}`);
        ws.send(`brake sent at: ${formattedDateString}`);
        ws.send(`estimatedDistance: ${distance}m`);
        ws.send(`speed: ${speed}km/h`);
        ws.send(`estimatedBrakingDistance: ${brakeDistance}m`);

        //ws.send("disconnect");
        ws.send("----------");
    }

    async function getCurrentTimeInString() {
        const time = await (await fetch("/time")).json();
        const date = new Date(time.now);
        const hour = date.getHours();
        const minutes = date.getMinutes();
        const seconds = date.getSeconds();
        const milliseconds = date.getMilliseconds();
        const formattedDateString = `${hour}:${minutes}:${seconds + milliseconds / 1000}`;
        return formattedDateString;
    }

    const startDetectionButton = document.querySelector("#startDetectionButton");
    startDetectionButton.addEventListener("click", () => {
        ws.send("startcam");
    });

</script>
<style>
    body {
        --primaryColor: rgba(255, 167, 5, 255);
        --secondryColor: rgba(39, 255, 179, 255);
    }

    body {
        font-family: Arial;
    }

    #header {
        display: flex;
        flex-direction: row;
        justify-content: center;

        h1 {
            font-size: larger;
        }
    }

    section {
        border: 1px solid gray;
        padding: 10px;
        display: flex;
        flex-direction: column;
        align-items: center;
    }

    button {
        padding: 5px;
        border: none;
        background-color: var(--primaryColor);
        border-radius: 5px;
        width: 150px;
        height: 30px;
        transition: all 0.125s ease-out;
    }

    button:hover {
        background-color: var(--secondryColor);
        cursor: pointer;
    }

    #socket-logs{
        .log{
            display: flex;
            flex-direction: row;
            gap: 20px;
            align-items: center;
            width: calc(100vw - 100px);
            p{
                border-left: 2px solid var(--primaryColor);
                padding-left: 10px;
            }
            border-bottom: 1px dashed gray;
        }
    }
</style>

</html>